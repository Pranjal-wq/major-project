Analysis summary:
- scanned files: 13
- total findings: 148

Per-file summary (first 40 entries):
- input\00000021.py : 13 findings
- input\api_redirection.py : 7 findings
- input\controlFlow.py : 5 findings
- input\controlflow_flattening.py : 9 findings
- input\deadcode.py : 17 findings
- input\dynamic_loading.py : 6 findings
- input\inlineExpansion.py : 17 findings
- input\instruction_substitution.py : 13 findings
- input\junkcode.py : 18 findings
- input\mixed_language.py : 5 findings
- input\nameIdentifier.py : 9 findings
- input\opaque_predicate.py : 23 findings
- input\stringEncryption.py : 6 findings

===== String Encryption =====

input\stringEncryption.py: obf-line: # Match only well-formed numeric arrays like [65, 66, 67] -> deobf-line: # Match only well-formed numeric arrays like "khi" (XOR-encrypted string detected and decrypted)



===== Identifier Cleaner =====

input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))
input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))
input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))
input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))
input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))
input\junkcode.py: m1 -> var1 (Obfuscated identifier replaced (m1 → var1))
input\junkcode.py: m2 -> var2 (Obfuscated identifier replaced (m2 → var2))



===== Control Flow =====

input\deadcode.py: if False:
    print("Dead branch")
 ->  (Unreachable branch (condition always False))
input\deadcode.py: if False: ...` blocks
      - replace `if True: body` with `body` (in-place)
      - record lines removed
    """
    def __init__(self):
        self.changes = []
 ->  (Unreachable branch (condition always False))
input\deadcode.py: if True:
    print("Always runs")
 -> print("Always runs")
 (Always-true condition simplified (kept body, removed if header))
input\deadcode.py: if True:
    print("Run")
 -> print("Run")
 (Always-true condition simplified (kept body, removed if header))
input\deadcode.py: if(false) { ... }` blocks ->  (Unreachable branch (condition always false))
input\deadcode.py: if(false) { ... } or if(false) statement; ->  (Unreachable branch (condition always false))
input\deadcode.py: if(false) removed (dead code)"}) ->  (Unreachable branch (condition always false))
input\deadcode.py: if(true) { ... }` with block contents (strip braces) -> { ... }` with block contents (strip braces) (Always-true condition simplified (kept statement/block, removed condition header))
input\deadcode.py: if(true) { block } => replace with block contents -> { block } => replace with block contents (Always-true condition simplified (kept statement/block, removed condition header))
input\deadcode.py: if(true) inlined (kept body)"}) ->  inlined (kept body)"}) (Always-true condition simplified (kept statement/block, removed condition header))



===== Dead Code =====

input\00000021.py: import base64
import unittest
import builtins

def api_redirection(a, b):
    def _real_api_add(x, y):
        return x + y
    def _wrapper -> import base64
import unittest
import builtins

def api_redirection(a, b):

    def _real_api_add(x, y):
        return x + y

    def _wrapp (Full cleaned file (Python deadcode removal))
input\00000021.py: code_after_return at 308
input\00000021.py: code_after_return at 2057
input\api_redirection.py: # analyzers/api_redirection.py
"""
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else -> """
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else
  - multiple-level wrappers
Cl (Full cleaned file (Python deadcode removal))
input\api_redirection.py: code_after_return at 436
input\api_redirection.py: code_after_return at 724
input\api_redirection.py: code_after_return at 1066
input\api_redirection.py: code_after_return at 1233
input\controlFlow.py: # -------------------- controlflow.py --------------------
import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    " -> import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    """
    Detect and clean fake/unreachable conditions from so (Full cleaned file (Python deadcode removal))
input\controlFlow.py: code_after_return at 3160
input\controlflow_flattening.py: # analyzers/controlflow_flattening.py
"""
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Cons -> """
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Conservative detection + optional simple u (Full cleaned file (Python deadcode removal))
input\controlflow_flattening.py: code_after_return at 1225
input\deadcode.py: """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   -> """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   (parse_error: unterminated triple-quoted string literal (detected at line 262) (<unknown>, line 223))
input\dynamic_loading.py: # analyzers/dynamic_loading.py
"""
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr -> """
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr/locals tricks
 - C/C++: functi (Full cleaned file (Python deadcode removal))
input\dynamic_loading.py: code_after_return at 1921
input\inlineExpansion.py: """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid -> """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid (Full cleaned file (Python deadcode removal))
input\instruction_substitution.py: # analyzers/instruction_substitution.py
"""
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x    -> """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick (Full cleaned file (Python deadcode removal))
input\junkcode.py: # analyzers/junk_code.py
"""
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation -> """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  (Full cleaned file (Python deadcode removal))
input\junkcode.py: code_after_return at 1566
input\mixed_language.py: # analyzers/mixed_language.py
"""
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - pre -> """
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - presence of JNI-like bridging cod (Full cleaned file (Python deadcode removal))
input\mixed_language.py: code_after_return at 1478
input\nameIdentifier.py: import re
import ast
import keyword
import builtins

# ----------------------------------------
# Reserved keywords for multiple languages
# -> import re
import ast
import keyword
import builtins
LANG_KEYWORDS = {'python': set(keyword.kwlist) | set(dir(builtins)), 'c': {'auto', 'brea (Full cleaned file (Python deadcode removal))
input\nameIdentifier.py: code_after_return at 442
input\nameIdentifier.py: code_after_return at 1078
input\nameIdentifier.py: code_after_return at 1577
input\nameIdentifier.py: code_after_return at 1828
input\opaque_predicate.py: # Opaque Predicate Complex Test Cases

# 1. Always true with redundant check inside loop

"""for i in range(2):
    if (2 + 2 == 4) and (3 > -> """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f (Full cleaned file (Python deadcode removal))
input\stringEncryption.py: import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join(chr(c ^  -> import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join((chr(c ^ (Full cleaned file (Python deadcode removal))



===== Inline Expansion =====

input\00000021.py: import base64
import unittest
import builtins

def api_redirection(a, b):

    def _real_api_add(x, y):
        return x + y

    def _wrapp -> import base64
import unittest
import builtins

def api_redirection(a, b):

    def _real_api_add(x, y):
        return x + y

    def _wrapp (Full cleaned file (Python inline folding))
input\00000021.py: const-arith '3 + 6'
input\api_redirection.py: """
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else
  - multiple-level wrappers
Cl -> """
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else
  - multiple-level wrappers
Cl (Full cleaned file (Python inline folding))
input\controlFlow.py: import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    """
    Detect and clean fake/unreachable conditions from so -> import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    """
    Detect and clean fake/unreachable conditions from so (Full cleaned file (Python inline folding))
input\controlflow_flattening.py: '// Suggested deobfuscated sequence\n' + '/* case1 */\n' -> '// Suggested deobfuscated sequence\n/* case1 */\n' (Constant folded)
input\controlflow_flattening.py: """
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Conservative detection + optional simple u -> """
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Conservative detection + optional simple u (Full cleaned file (Python inline folding))
input\controlflow_flattening.py: const-arith '2-3'
input\deadcode.py: """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   -> """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   (parse_error: unterminated triple-quoted string literal (detected at line 262) (<unknown>, line 223))
input\dynamic_loading.py: """
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr/locals tricks
 - C/C++: functi -> """
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr/locals tricks
 - C/C++: functi (Full cleaned file (Python inline folding))
input\inlineExpansion.py: """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid -> """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid (Full cleaned file (Python inline folding))
input\inlineExpansion.py: const-arith '12 * 4'
input\inlineExpansion.py: const-arith '50 + 25'
input\inlineExpansion.py: const-arith '2 * 5'
input\inlineExpansion.py: const-arith '1 + 2'
input\inlineExpansion.py: const-arith '3 + 4'
input\inlineExpansion.py: const-arith '5 + 5'
input\inlineExpansion.py: const-arith '2 * 3'
input\inlineExpansion.py: const-arith '4 * 5'
input\inlineExpansion.py: const-arith '2 + 3'
input\inlineExpansion.py: const-arith '2 + 2'
input\inlineExpansion.py: const-arith '3 * 3'
input\instruction_substitution.py: """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick -> """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick (Full cleaned file (Python inline folding))
input\instruction_substitution.py: const-arith '2
  - 2'
input\instruction_substitution.py: const-arith '1 + 1'
input\instruction_substitution.py: const-arith '1 * 2'
input\instruction_substitution.py: const-arith '1 + 1'
input\junkcode.py: """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  -> """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  (Full cleaned file (Python inline folding))
input\mixed_language.py: """
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - presence of JNI-like bridging cod -> """
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - presence of JNI-like bridging cod (Full cleaned file (Python inline folding))
input\nameIdentifier.py: import re
import ast
import keyword
import builtins
LANG_KEYWORDS = {'python': set(keyword.kwlist) | set(dir(builtins)), 'c': {'auto', 'brea -> import re
import ast
import keyword
import builtins
LANG_KEYWORDS = {'python': set(keyword.kwlist) | set(dir(builtins)), 'c': {'auto', 'brea (Full cleaned file (Python inline folding))
input\opaque_predicate.py: """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f -> """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f (Full cleaned file (Python inline folding))
input\opaque_predicate.py: const-arith '2 + 2'
input\opaque_predicate.py: const-arith '2 * 3'
input\opaque_predicate.py: const-arith '4 - 1'
input\opaque_predicate.py: const-arith '50 - 25'
input\opaque_predicate.py: const-arith '9 % 2'
input\opaque_predicate.py: const-arith '10/2'
input\opaque_predicate.py: const-arith '3*3'
input\opaque_predicate.py: const-arith '16/4'
input\opaque_predicate.py: const-arith '0-9'
input\stringEncryption.py: import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join((chr(c ^ -> import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join((chr(c ^ (Full cleaned file (Python inline folding))
input\stringEncryption.py: const-arith '0-9'



===== Opaque Predicates =====

input\00000021.py: import base64
import unittest
import builtins

def api_redirection(a, b):

    def _real_api_add(x, y):
        return x + y

    def _wrapp -> import base64
import unittest
import builtins

def api_redirection(a, b):

    def _real_api_add(x, y):
        return x + y

    def _wrapp (Full cleaned file (Python opaque predicate simplification))
input\api_redirection.py: """
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else
  - multiple-level wrappers
Cl -> """
Detect API redirection/wrapper patterns:
  - tiny wrappers that call another function and do nothing else
  - multiple-level wrappers
Cl (Full cleaned file (Python opaque predicate simplification))
input\controlFlow.py: import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    """
    Detect and clean fake/unreachable conditions from so -> import re
from typing import List, Dict, Tuple

class FakeConditionCleaner:
    """
    Detect and clean fake/unreachable conditions from so (Full cleaned file (Python opaque predicate simplification))
input\controlflow_flattening.py: """
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Conservative detection + optional simple u -> """
Detect/control-flow flattening patterns (dispatcher loops, state-machine switch inside loop).
Conservative detection + optional simple u (Full cleaned file (Python opaque predicate simplification))
input\deadcode.py: """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   -> """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   (parse_error: unterminated triple-quoted string literal (detected at line 262) (<unknown>, line 223))
input\dynamic_loading.py: """
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr/locals tricks
 - C/C++: functi -> """
Detect dynamic code loading/reflection/indirect calls:
 - Python: eval, exec, compile, importlib, getattr/locals tricks
 - C/C++: functi (Full cleaned file (Python opaque predicate simplification))
input\inlineExpansion.py: """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid -> """# Inline Expansion Complex Test Cases with Loops

# 1. Constant multiplication inside assignment
a = 12 * 4

# 2. Constant addition insid (Full cleaned file (Python opaque predicate simplification))
input\instruction_substitution.py: """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick -> """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick (Full cleaned file (Python opaque predicate simplification))
input\junkcode.py: """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  -> """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  (Full cleaned file (Python opaque predicate simplification))
input\mixed_language.py: """
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - presence of JNI-like bridging cod -> """
Detect mixed-language obfuscation signals, such as:
 - inline assembly or ASM blocks inside C/C++  
 - presence of JNI-like bridging cod (Full cleaned file (Python opaque predicate simplification))
input\nameIdentifier.py: import re
import ast
import keyword
import builtins
LANG_KEYWORDS = {'python': set(keyword.kwlist) | set(dir(builtins)), 'c': {'auto', 'brea -> import re
import ast
import keyword
import builtins
LANG_KEYWORDS = {'python': set(keyword.kwlist) | set(dir(builtins)), 'c': {'auto', 'brea (Full cleaned file (Python opaque predicate simplification))
input\opaque_predicate.py: """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f -> """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f (Full cleaned file (Python opaque predicate simplification))
input\opaque_predicate.py: constant-compare '2 + 2 == 4'
input\opaque_predicate.py: constant-compare '2 * 3 == 6'
input\opaque_predicate.py: constant-compare '4 - 1 == 3'
input\opaque_predicate.py: constant-compare '50 - 25 == 25'
input\opaque_predicate.py: constant-compare '16/4 == 4'
input\stringEncryption.py: import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join((chr(c ^ -> import re

def xor_decrypt(enc_list, key=42):
    """XOR decrypt a list of integers to a string."""
    try:
        return ''.join((chr(c ^ (Full cleaned file (Python opaque predicate simplification))



===== Control Flow Flattening =====

input\00000021.py:  ->  (Detected Python flattened control-flow patterns. Manual reconstruction recommended.)
input\00000021.py: goto/switch/state-like patterns present
input\controlflow_flattening.py:  ->  (Detected Python flattened control-flow patterns. Manual reconstruction recommended.)
input\controlflow_flattening.py: goto/switch/state-like patterns present
input\deadcode.py: goto/switch/state-like patterns present
input\inlineExpansion.py:  ->  (Detected Python flattened control-flow patterns. Manual reconstruction recommended.)
input\nameIdentifier.py: goto/switch/state-like patterns present



===== Instruction Substitution =====

input\instruction_substitution.py: x - (-1) -> x + 1 (Canonicalized: neg-neg to plus)
input\instruction_substitution.py: x + x -> 2 * x (Canonicalized: x+x to 2*x)
input\instruction_substitution.py: x+x -> 2 * x (Canonicalized: x+x to 2*x)
input\instruction_substitution.py: x+x -> 2 * x (Canonicalized: x+x to 2*x)
input\instruction_substitution.py: """
Detect instruction substitution like:
  - x - (-1)  -> x + 1
  - x << 1    -> x * 2
  - x + x     -> 2 * x  (or x * 2)
  - bitwise trick -> """
Detect instruction substitution like:
  - x + 1  -> x + 1
  - x << 1    -> x * 2
  - 2 * x     -> 2 * x  (or x * 2)
  - bitwise tricks ( (Applied instruction substitution canonicalization (Python))



===== Dynamic Code Loading =====

input\00000021.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 81, 'snippet': 'getattr(', 'reason': 'dynamic execution/reflection'}])
input\controlFlow.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 14, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 14, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 14, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 15, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 15, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 15, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\controlflow_flattening.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\deadcode.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 228, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 237, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 252, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 129, 'snippet': 'getattr(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 144, 'snippet': 'getattr(', 'reason': 'dynamic execution/reflection'}])
input\dynamic_loading.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\dynamic_loading.py: reflection/dynamic API: Class.forName
input\inlineExpansion.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 153, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\instruction_substitution.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 11, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 32, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 32, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\opaque_predicate.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 198, 'snippet': 'eval(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 192, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}, {'type': 'dynamic_py', 'lineno': 235, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])
input\stringEncryption.py:  ->  (Detected dynamic constructs (eval/exec/compile/reflection). Manual review required: [{'type': 'dynamic_py', 'lineno': 18, 'snippet': 'compile(', 'reason': 'dynamic execution/reflection'}])



===== Junk Code =====

input\deadcode.py: """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   -> """# Dead Code Test Cases

# 1. Unused variable
x = 10   # dead
y = 20
print(y)

# 2. If condition always True
print("Always runs")
else:
   (Removed redundant pass statements)
input\junkcode.py: """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  -> """
Detect/remove junk code: NOPs, identity operations, redundant arithmetic, dead stores used only for obfuscation.
Conservative cleaning:  (Removed identity addition (x = x + 0).)
input\junkcode.py: smali NOP found
input\mixed_language.py: smali NOP found
input\opaque_predicate.py: """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f -> """for i in range(2):
    if (2 + 2 == 4) and (3 > 1):
        print("Loop always true:", i)

# 2. Always false predicate (never executes)
f (Removed redundant pass statements)



===== API Redirection =====

input\00000021.py: wrapper-call-like: return _real_api_add(
input\00000021.py: wrapper-call-like: return _wrapper(
input\00000021.py: wrapper-call-like: return b(
input\00000021.py: wrapper-call-like: return func(
input\inlineExpansion.py: wrapper-call-like: return str(
input\nameIdentifier.py: wrapper-call-like: return bool(
input\opaque_predicate.py: wrapper-call-like: return all(
input\opaque_predicate.py: wrapper-call-like: return any(
input\opaque_predicate.py: wrapper-call-like: return eval(



===== Mixed Language Obfuscation =====

No cases detected.



===== Identifier Obfuscation =====

input\deadcode.py: many short identifiers (36) — possible ProGuard renames
input\opaque_predicate.py: many short identifiers (32) — possible ProGuard renames

